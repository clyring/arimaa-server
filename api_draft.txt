
################################################################################
Arimaa Game Server JSON API
################################################################################

#TODO - see todos below

All requests and responses are in JSON.

Shared types:
<Message> = {"message":<String>}
<Error> = {"error":<String>}
<GameID> = <String> #Alphanumeric hash used as an identifier for a game
<Auth> = <String>  #Authorization token returned from logging in
<GameAuth> = <String>  #Authorization token returned from joining a game
<Username> = <String>
#TODO - should this be an int with the number of milliseconds?
<Timestamp> = <Float> #Seconds since the epoch (1970-01-01 00:00 UTC) (up to however much precision the server has)

===ACCOUNTS========================================================
To register an account:
#TODO How to prevent spamming of registration of new accounts?
#TODO add country? (how to standardize it as a string? or use an integer enum code?)
POST /accounts/register {"username":<Username>,"email":<String>,"password":<String>,"isBot":<Bool>}

#TODO add other account facilities
#TODO add ways of looking up users

===LOGIN===========================================================
To log in:
POST /accounts/login {"username":<Username>,"password":<String>}
Response if successful = {"username":<Username>,"auth":<Auth>}
Response if not successful = <Error>

To log out:
POST /accounts/logout {"auth":<Auth>}
Response if successful = <Message>
Response if not successful = <Error>

===GAMEROOM========================================================
<UserInfo> = {
  "username":<Username>,
  "isBot"<Bool>,
  "rating":<Float>
}

<GameResult> = {
  "winner":<String>, #"g" or "s", or "n" if there was no winner
  "resultCode":<String>, #TODO - describe this. Same as current Arimaa resultCode system seems okay
  "endTime":<Timestamp>
}

<PlayerTimeControl> = {
  #All values are in seconds
  "initialTime":<Int>, #The initial amount of time a player begins with on the clock
  "increment":<Int>,   #Time added to a player's clock after the completion of each move
  "delay":<Int>,       #Length of time into a move before a player's clock actually begins decrementing
  "maxReserve":<Int>,  #OPTIONAL - if present, the maximum amount of time that can be stored
  "maxMoveTime":<Int>, #OPTIONAL - if present, the maximum allowed time for a player to make one move
  "maxGameTime::<Int>, #OPTIONAL - if present, the maximum allowed time for the game
}

<GameMetadata> = {
  "id":<GameID>,
  "numPly":<Int>, #Total number of half-moves made in the game (ex: {1g, 1s, 2g, 2s, 3g} = 5 ply)
  "startTime":<Timestamp> #Time that the game clock was started
  "gUser":<UserInfo>,
  "sUser":<UserInfo>,
  "gTC":<PlayerTimeControl>, #Time control for Gold
  "sTC":<PlayerTimeControl>, #Time control for Silver
  "rated":<Bool>, #Whether the game was used for rating calculations
  "experimental":<Bool>, #Whether the game allows nontraditional setups (handicaps, alternate starting positions)
  "active":<Bool> #Whether the game is open or is being played right now
  "result":<GameResult> #ONLY present if the game is not active!
}

<GameState> = {
  "history":[<String>,<String>,<String>,...], #Move history in the order [1g,1s,2g,2s...] ex: ["Ra1","Ra7","Ra1n Ra2n Ra3n Ra4n"]
  "moveTimes":[<Timestamp>,<Timestamp>,<Timestamp>,...], #Time that each move was received and played
  "toMove":<String>,  #Next player to move, either "g" or "s"
  #TODO - should this be a FEN-style string?
  "position":<String> #64-char string specifying the board in the order a8-h8,a7-h7,...,a1-h1
                      #ex:"rrrrrrrrchdemdhc                                CHDMEDHCRRRRRRRR"
  "meta":<GameMetadata>,
  "lastMoveTime":<Timestamp>, #Time that the previous move was recieved and made
  "timeSpent":<Float>, #Seconds since the start of this move
  "gTimeThisMove":<Float>, #Seconds on gold's clock at the start of this move
  "sTimeThisMove":<Float>, #Seconds on silver's's clock at the start of this move
  "gPresent":<Bool>, #Whether gold is present and connected to the game, always false if the game is finished
  "sPresent":<Bool>, #Whether silver is present and connected to the game, always false if the game is finished
  "now":<Timestamp>  #Server timestamp as of the reporting of this gamestate
}

To get just the metadata about a game;
GET /game/<GameID>/metadata
Response if successful = <GameMetadata>
Response if not successful = <Error>
#TODO - note that this will also accept old arimaa.com numeric game ids in place of <GameID>

To get the full state of a game:
GET /game/<GameID>/state
GET /game/<GameID>/state?minPly=<INT>&timeout=<INT>
Response if successful = <GameState>
Response if not successful = <Error>
If 'minPly' is specified, the current game is active, and 'numPly' < 'minPly', blocks until either
'timeout' seconds have passed (default 15), the game ends (timeout, resignation, etc.) or a move
is played causing 'numPly' >= 'minPly'.
#TODO - note that this will also accept old arimaa.com numeric game ids in place of <GameID>

#TODO - interface for creating a game
#TODO - detect timeouts via heartbeating?

To join a game:
POST /games/<GameID>/actions/join {"auth":<Auth>}
Response if successful = {"gameauth":<GameAuth>}
Response if not successful = <Error>

To leave, resign a game, make a move:
POST /games/<GameID>/actions/leave {"auth":<Auth>}
POST /games/<GameID>/actions/resign {"gameauth":<GameAuth>}
POST /games/<GameID>/actions/move {
  "gameauth":<GameAuth>,
  "move":<String>, #ex: Ra1n Ra2n Ra3e Rb3e Rc3x"
  "moveNum:<Int>   #1g = 0, 1s = 1, 2g = 2, 2s = 3, ...
}
Response if successful = <Message>
Response if not successful = <Error>

To get a list of all games satisfying:
GET /games/search?key=value&key=value&...
Legal keys and values:
  player1=<UserName>  #Involves the given user
  player2=<UserName>  #Involves the given user
  gplayer=<UserName>  #Gold player is the given user
  splayer=<UserName>  #Silver player is the given user
  rated=<Bool>        #Require games to be rated or unrated
  experimental=<Bool> #Require games to be experimental or not
  active=<Bool>       #Require games to be active or not
  limit=<Int>         #Limit the number of returned games to this many (default 100, max 1000)
  mintime=<Int>       #game occurs on or after this timestamp
  maxtime=<Int>       #game occurs on or before this timestamp
  mindate=<String>    #ex: 2015-01-01, game occurs on or after this date in the given timezone
  maxdate=<String>    #ex: 2015-01-01, game occurs on or before this date in the given timezone
  zone=<String>       #Timezone for mindate and maxdate, default UTC

Response if successful = [<GameMetadata>,<GameMetadata>,...]
Response if not successful = <Error>
